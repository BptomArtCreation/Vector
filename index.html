<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vector Studio (iOS Glass Ultimate)</title>
    <style>
        :root {
            --glass-bg: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.2);
            --accent: #0A84FF;
            --accent-gradient: linear-gradient(135deg, #0A84FF, #5E5CE6);
            --text-main: #ffffff;
            --text-sub: rgba(255, 255, 255, 0.6);
        }

        body {
            margin: 0; font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
            background: #000; color: var(--text-main); height: 100vh; display: flex; overflow: hidden;
            /* Ê∑±Ëâ≤Ê•µÂÖâËÉåÊôØ */
            background-image: 
                radial-gradient(at 0% 0%, #1a1a2e 0, transparent 50%), 
                radial-gradient(at 50% 100%, #16213e 0, transparent 50%), 
                radial-gradient(at 100% 0%, #4a1c40 0, transparent 50%);
        }

        /* ÂÖâÊöàÂãïÁï´ */
        .glow { position: absolute; border-radius: 50%; filter: blur(90px); z-index: -1; opacity: 0.4; animation: float 10s infinite alternate; }
        .glow-1 { top: -10%; left: -10%; width: 60vw; height: 60vw; background: #0A84FF; }
        .glow-2 { bottom: -10%; right: -10%; width: 50vw; height: 50vw; background: #BF5AF2; animation-delay: -5s; }
        @keyframes float { from {transform: translate(0,0);} to {transform: translate(30px, 50px);} }

        aside {
            width: 320px; background: rgba(30,30,30,0.4); backdrop-filter: blur(30px); -webkit-backdrop-filter: blur(30px);
            border-right: 1px solid var(--glass-border); display: flex; flex-direction: column; padding: 30px; z-index: 10; overflow-y: auto;
        }

        h1 { font-size: 24px; font-weight: 700; margin: 0 0 30px 0; letter-spacing: -0.5px; }
        h1 span { color: #0A84FF; }
        h2 { font-size: 12px; text-transform: uppercase; color: var(--text-sub); margin: 30px 0 15px 0; font-weight: 600; letter-spacing: 1px; }

        .control-group { margin-bottom: 20px; }
        label { display: flex; justify-content: space-between; font-size: 14px; margin-bottom: 10px; color: var(--text-main); }
        label span { font-family: monospace; color: var(--accent); }

        /* iOS Style Sliders */
        input[type="range"] { -webkit-appearance: none; width: 100%; height: 5px; background: rgba(255,255,255,0.2); border-radius: 5px; outline: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: white; border-radius: 50%; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.3); transition: transform 0.1s; }
        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.1); }

        .btn {
            background: var(--accent-gradient); color: white; border: none; padding: 14px; border-radius: 14px;
            font-size: 16px; font-weight: 600; cursor: pointer; margin-top: 10px; width: 100%;
            box-shadow: 0 4px 15px rgba(10, 132, 255, 0.3); transition: 0.2s;
        }
        .btn:active { transform: scale(0.98); }
        .btn-outline { background: rgba(255,255,255,0.1); box-shadow: none; border: 1px solid rgba(255,255,255,0.1); }
        .btn-outline:hover { background: rgba(255,255,255,0.2); }

        /* Toggle Switch */
        .switch-wrap { display: flex; align-items: center; justify-content: space-between; background: rgba(255,255,255,0.1); padding: 12px; border-radius: 12px; cursor: pointer; }
        .toggle { position: relative; width: 40px; height: 24px; background: rgba(255,255,255,0.2); border-radius: 20px; transition: 0.3s; }
        .toggle::after { content:''; position: absolute; top: 2px; left: 2px; width: 20px; height: 20px; background: white; border-radius: 50%; transition: 0.3s; }
        input[type="checkbox"] { display: none; }
        input[type="checkbox"]:checked + .toggle { background: #30D158; }
        input[type="checkbox"]:checked + .toggle::after { transform: translateX(16px); }

        main { flex: 1; position: relative; display: flex; align-items: center; justify-content: center; }
        main.drag-active::after {
            content: 'Drop Image Here'; position: absolute; inset: 20px; border: 3px dashed var(--accent);
            border-radius: 20px; background: rgba(10, 132, 255, 0.2); z-index: 50;
            display: flex; align-items: center; justify-content: center; font-size: 24px; font-weight: bold; color: white; pointer-events: none;
        }

        .canvas-container {
            position: relative; width: 80%; height: 80%; border-radius: 8px;
            box-shadow: 0 30px 60px rgba(0,0,0,0.5); overflow: hidden;
            background-image: linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 20px 20px; background-color: white;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .layer { width: 100%; height: 100%; object-fit: contain; display: block; }
        .original-layer { position: absolute; top:0; left:0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; }
        .vector-layer-mask {
            position: absolute; top:0; left:0; width: 50%; height: 100%; overflow: hidden;
            border-right: 1px solid white; box-shadow: 5px 0 15px rgba(0,0,0,0.3);
            background: rgba(255,255,255,0.05);
        }
        
        /* SVG ÂÆπÂô®‰øÆÊ≠£ÔºöÁ¢∫‰øùÂÆÉ‰ΩîÊªøÊï¥ÂÄãÁ©∫Èñì‰ΩÜÂÖßÂÆπÁΩÆ‰∏≠ */
        #svgContainer { width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; }
        #svgContainer svg { max-width: 100%; max-height: 100%; }

        .handle {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
            width: 44px; height: 44px; background: rgba(255,255,255,0.3); backdrop-filter: blur(10px);
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            cursor: col-resize; box-shadow: 0 4px 10px rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.5); z-index: 5;
        }
        .handle::after { content:'‚Üî'; color: white; font-weight: bold; }

        .upload-ui { position: absolute; z-index: 2; text-align: center; pointer-events: none; }
        .upload-btn { pointer-events: auto; background: rgba(255,255,255,0.1); backdrop-filter: blur(20px); padding: 40px 60px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.2); cursor: pointer; transition: 0.3s; }
        .upload-btn:hover { background: rgba(255,255,255,0.2); transform: scale(1.02); border-color: var(--accent); }

        .loading-pill {
            position: absolute; bottom: 30px; background: rgba(0,0,0,0.7); backdrop-filter: blur(10px);
            padding: 10px 20px; border-radius: 20px; display: flex; align-items: center; gap: 10px;
            transform: translateY(100px); transition: 0.3s; border: 1px solid rgba(255,255,255,0.1);
        }
        .loading-pill.show { transform: translateY(0); }
        .spin { width: 14px; height: 14px; border: 2px solid #888; border-top-color: white; border-radius: 50%; animation: spin 1s infinite linear; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Èö±ËóèÊØîËºÉË¶ñÁ™óÁõ¥Âà∞ÊúâÂúñÁâá */
        #compareWrapper { display: none; width: 100%; height: 100%; }
    </style>

    <!-- 
      === ÈóúÈçµ‰øÆÂæ© ===
      Â∞á ImageTracer Ê†∏ÂøÉ‰ª£Á¢ºÁõ¥Êé•ÊîæÂú®ÈÄôË£°Ôºå‰∏çÂåÖË£π‰ªª‰Ωï function„ÄÇ
      ÈÄôÊ®£ÂÆÉÂ∞±ÊúÉÁõ¥Êé•ÊàêÁÇ∫ window.ImageTracer ÂÖ®ÂüüËÆäÊï∏„ÄÇ
    -->
    <script>
        var ImageTracer = {
            versionNumber: "1.2.6",
            optionpresets: {
                default: { corsenabled: !1, ltres: 1, qtres: 1, pathomit: 8, rightangleenhance: !0, colorsampling: 2, numberofcolors: 16, mincolorratio: 0, colorquantcycles: 3, layering: 0, strokewidth: 1, linefilter: !1, scale: 1, roundcoords: 1, viewbox: !1, desc: !1, lcpr: 0, qcpr: 0, blurradius: 0, blurdelta: 20 },
                posterized1: { colorsampling: 0, numberofcolors: 2 },
                posterized2: { numberofcolors: 4, blurradius: 5 },
                curvy: { ltres: 0.01, linefilter: !0, rightangleenhance: !1 },
                sharp: { qtres: 0.01, linefilter: !1 },
                detailed: { pathomit: 0, roundcoords: 2, ltres: 0.5, qtres: 0.5, numberofcolors: 64 },
                smoothed: { blurradius: 5, blurdelta: 20 },
                grayscale: { colorsampling: 0, colorquantcycles: 1, numberofcolors: 7 },
                fixedpalette: { colorsampling: 0, colorquantcycles: 1, numberofcolors: 27 },
                randomsampling1: { colorsampling: 1, numberofcolors: 8 },
                randomsampling2: { colorsampling: 1, numberofcolors: 64 },
                artistic1: { colorsampling: 0, colorquantcycles: 1, pathomit: 0, blurradius: 5, blurdelta: 25, ltres: 0.01, linefilter: !0, numberofcolors: 16, strokewidth: 2 },
                artistic2: { qtres: 0.01, colorsampling: 0, colorquantcycles: 1, numberofcolors: 4, strokewidth: 0 },
                artistic3: { qtres: 10, ltres: 10, numberofcolors: 8 },
                artistic4: { qtres: 10, ltres: 10, numberofcolors: 64, blurradius: 5, blurdelta: 25, ltres: 0.01, linefilter: !0, strokewidth: 2 },
                posterized3: { ltres: 1, qtres: 1, pathomit: 20, rightangleenhance: !0, colorsampling: 0, numberofcolors: 3, mincolorratio: 0, colorquantcycles: 3, blurradius: 3, blurdelta: 20, strokewidth: 0, roundcoords: 1, pal: [{ r: 0, g: 0, b: 100, a: 255 }, { r: 255, g: 255, b: 255, a: 255 }, { r: 0, g: 0, b: 0, a: 255 }] }
            },
            imageToSVG: function (t, r, e) { e = ImageTracer.checkoptions(e); var n = new Image; n.src = t, n.onload = function () { var t = document.createElement("canvas"); t.width = n.width, t.height = n.height; var o = t.getContext("2d"); o.drawImage(n, 0, 0); var i = o.getImageData(0, 0, n.width, n.height); ImageTracer.imagedataToSVG(i, function (t) { r(t) }, e) } },
            imagedataToSVG: function (t, r, e) { e = ImageTracer.checkoptions(e); var n = ImageTracer.imagedataToTracedata(t, e); return r ? void r(ImageTracer.getsvgstring(n, e)) : ImageTracer.getsvgstring(n, e) },
            imageToTracedata: function (t, r, e) { e = ImageTracer.checkoptions(e); var n = new Image; n.src = t, n.onload = function () { var t = document.createElement("canvas"); t.width = n.width, t.height = n.height; var o = t.getContext("2d"); o.drawImage(n, 0, 0); var i = o.getImageData(0, 0, n.width, n.height); ImageTracer.imagedataToTracedata(i, function (t) { r(t) }, e) } },
            imagedataToTracedata: function (t, r, e) { e = ImageTracer.checkoptions(e); var n = ImageTracer.colorquantization(t, e); 0 === e.layering && (n = ImageTracer.layering(n)); var o = null, i = null, a = null; return o = e.layering ? ImageTracer.layeringstep(n, e) : n, i = ImageTracer.batchpathscan(o, e.pathomit), a = ImageTracer.batchinternodes(i, e), a = ImageTracer.batchtracelayers(a, e.ltres, e.qtres), a = ImageTracer.batchcolorlayers(a, o, e.pal), r ? void r(a) : a },
            checkoptions: function (t) { var r = JSON.parse(JSON.stringify(ImageTracer.optionpresets.default)); for (var e in t) t.hasOwnProperty(e) && (r[e] = t[e]); return r },
            colorquantization: function (t, r) { var e = [], n = t.data, o = 0, i = 0, a = 0, s = 0, l = t.width, c = t.height, u = r.pal; if (u) for (var d = 0; d < n.length; d += 4) { var h = 255, f = 255, m = 255, p = 255, g = 0; for (var v = 0; v < u.length; v++) { var b = u[v], y = Math.abs(n[d] - b.r), w = Math.abs(n[d + 1] - b.g), k = Math.abs(n[d + 2] - b.b), x = Math.abs(n[d + 3] - b.a), T = y + w + k + x; T < h && (h = T, f = y, m = w, p = k, g = v) } e[d / 4] = g } else { var C = parseInt(Math.sqrt(r.numberofcolors)); C < 2 && (C = 2); var M = n.length; if (0 === r.colorsampling) for (var S = 0; S < r.numberofcolors; S++) { var I = Math.floor(S * M / (4 * r.numberofcolors)); e[I] = S } else if (1 === r.colorsampling) for (var S = 0; S < r.numberofcolors; S++) { var I = Math.floor(Math.random() * M / 4); e[I] = S } else if (2 === r.colorsampling) for (var S = 0; S < r.colorquantcycles; S++) { var O = Math.floor(M / 4 * (S + 1) / (r.colorquantcycles + 1)); e[O] = S } else for (var d = 0; d < M; d += 4) { var I = Math.floor(d / 4); e[I] = -1 } } return 2 === r.layering && (r.pal = u || ImageTracer.getpalette(t, r)), r.blurradius > 0 && (t = ImageTracer.blur(t, r.blurradius, r.blurdelta)), { array: e, width: l, height: c } },
            getpalette: function (t, r) { var e = [], n = t.data, o = r.numberofcolors; if (r.pal) return r.pal; for (var i = 0; i < o; i++)e.push({ r: Math.floor(Math.random() * 255), g: Math.floor(Math.random() * 255), b: Math.floor(Math.random() * 255), a: 255 }); for (var a = 0; a < r.colorquantcycles; a++) { for (var i = 0; i < o; i++)e[i].n = 0, e[i].r = 0, e[i].g = 0, e[i].b = 0, e[i].a = 0; for (var s = 0; s < n.length; s += 4) { var l = 255, c = 0; for (var i = 0; i < o; i++) { var u = Math.abs(n[s] - e[i].r) + Math.abs(n[s + 1] - e[i].g) + Math.abs(n[s + 2] - e[i].b) + Math.abs(n[s + 3] - e[i].a); u < l && (l = u, c = i) } e[c].n++, e[c].r += n[s], e[c].g += n[s + 1], e[c].b += n[s + 2], e[c].a += n[s + 3] } for (var i = 0; i < o; i++)e[i].n > 0 && (e[i].r = Math.floor(e[i].r / e[i].n), e[i].g = Math.floor(e[i].g / e[i].n), e[i].b = Math.floor(e[i].b / e[i].n), e[i].a = Math.floor(e[i].a / e[i].n)) } return e },
            layering: function (t) { for (var r = [], e = 0, n = 0, o = 0; o < t.array.length; o++) { var i = t.array[o]; if (i >= 0) { var a = 0; for (var s = 0; s < r.length; s++)i === r[s].val && (e = s, a = 1); a || (r.push({ val: i }), e = r.length - 1), r[e].data || (r[e].data = []), r[e].data.push(o) } else r[0] || r.push({ val: -1 }), r[0].data || (r[0].data = []), r[0].data.push(o) } return r },
            layeringstep: function (t, r) { for (var e = [], n = r.pal ? r.pal : [{ r: 0, g: 0, b: 0, a: 255 }, { r: 255, g: 255, b: 255, a: 255 }], o = 0; o < n.length; o++)e[o] = {}, e[o].data = []; for (var i = 0; i < t.array.length; i++) { var a = t.array[i]; e[a].data.push(i) } return e },
            pathscan: function (t, r, e) { var n = [], o = 0, i = 0, a = 0, s = 0, l = 0, c = 0, u = 0, d = 0, h = 0, f = 0, m = 0, p = 0, g = 0, v = 0, b = 0, y = 0; for (var w = 0; w < t.length; w++)t[w].cnt = 0; for (var k = 0; k < e; k++)for (var x = 0; x < r; x++)if (0 === t[k * r + x].cnt && 1 === t[k * r + x].val) { o = x, i = k, a = 1, s = 0, l = 0, n[n.length] = [], n[n.length - 1].points = [], n[n.length - 1].boundingbox = [x, x, k, k], n[n.length - 1].holechildren = []; var T = n.length - 1; c = x, u = k, d = 0; var C = !1; while (!C) { n[T].points.push({ x: c, y: u, t: d }), n[T].boundingbox[0] = Math.min(n[T].boundingbox[0], c), n[T].boundingbox[1] = Math.max(n[T].boundingbox[1], c), n[T].boundingbox[2] = Math.min(n[T].boundingbox[2], u), n[T].boundingbox[3] = Math.max(n[T].boundingbox[3], u), h = c + parseInt((d + 1) / 2) % 2, f = u + parseInt(d / 2) % 2, h >= 0 && h < r && f >= 0 && f < e ? m = t[f * r + h].val : m = 0, p = c + parseInt(d / 2) % 2, g = u + parseInt((d + 3) / 2) % 2, p >= 0 && p < r && g >= 0 && g < e ? v = t[g * r + p].val : v = 0, 1 === m && 0 === v ? (1 === d || 3 === d ? d = (d + 1) % 4 : d = (d + 3) % 4, 1 === d ? (b = 1, y = 0) : 2 === d ? (b = 0, y = 1) : 3 === d ? (b = -1, y = 0) : 0 === d && (b = 0, y = -1)) : 1 === m && 1 === v ? (d = (d + 3) % 4, 1 === d ? (b = 1, y = 0) : 2 === d ? (b = 0, y = 1) : 3 === d ? (b = -1, y = 0) : 0 === d && (b = 0, y = -1)) : 0 === m && 0 === v ? (1 === d || 3 === d ? d = (d + 3) % 4 : d = (d + 1) % 4, 1 === d ? (b = 1, y = 0) : 2 === d ? (b = 0, y = 1) : 3 === d ? (b = -1, y = 0) : 0 === d && (b = 0, y = -1)) : 0 === m && 1 === v && (1 === d || 3 === d ? d = (d + 1) % 4 : d = (d + 3) % 4, 1 === d ? (b = 1, y = 0) : 2 === d ? (b = 0, y = 1) : 3 === d ? (b = -1, y = 0) : 0 === d && (b = 0, y = -1)), c += b, u += y, c === o && u === i && d === a && (C = !0) } t[k * r + x].cnt = 1 } return n },
            batchpathscan: function (t, r) { for (var e = 0; e < t.length; e++) { var n = t[e]; n.width = Math.sqrt(n.data.length), n.height = n.width, n.batched = !0; for (var o = 0; o < n.data.length; o++)n.data[o] = { val: n.data[o], cnt: 0 }; n.paths = ImageTracer.pathscan(n.data, n.width, n.height), n.paths = n.paths.filter(function (t) { return t.points.length > r }) } return t },
            internodes: function (t, r) { var e = [], n = [], o = 0, i = 0, a = 0, s = 0, l = 0, c = 0, u = 0, d = 0; for (var h = 0; h < t.length; h++) { var f = t[h].points, m = f.length; e.push({ points: [] }); for (var p = 0; p < m; p++) { var g = f[p], v = f[(p + 1) % m]; e[e.length - 1].points.push({ x: g.x, y: g.y, linesgement: ImageTracer.getdirection(g.x, g.y, v.x, v.y) }) } } return e },
            getdirection: function (t, r, e, n) { var o = 0; return t < e ? r < n ? o = 1 : r > n ? o = 7 : o = 0 : t > e ? r < n ? o = 3 : r > n ? o = 5 : o = 4 : r < n ? o = 2 : r > n && (o = 6), o },
            batchinternodes: function (t, r) { for (var e = 0; e < t.length; e++)t[e].paths = ImageTracer.internodes(t[e].paths, r); return t },
            tracepath: function (t, r, e) { var n = 0, o = 0, i = 0, a = 0, s = [], l = [], c = 0, u = 0, d = 0, h = 0, f = 0, m = 0, p = 0, g = 0, v = 0, b = 0, y = 0, w = 0, k = 0, x = 0; for (var T = 0; T < t.points.length; T++)s[T] = t.points[T]; var C = s.length; while (C > 0) { var M = Math.floor(Math.random() * C); u = s[M].x, d = s[M].y, h = s[M].x, f = s[M].y, m = s[M].linesgement, p = s[M].linesgement, n = 0, o = 0, i = 0, a = 0, c = 0, l[l.length] = [], l[l.length - 1].type = m, l[l.length - 1].x1 = u, l[l.length - 1].y1 = d, l[l.length - 1].x2 = u, l[l.length - 1].y2 = d, l[l.length - 1].x3 = u, l[l.length - 1].y3 = d; var S = !1; while (!S) { 0 === m ? (h++, i++) : 1 === m ? (h++, f++, i++, a++) : 2 === m ? (f++, a++) : 3 === m ? (h--, f++, i--, a++) : 4 === m ? (h--, i--) : 5 === m ? (h--, f--, i--, a--) : 6 === m ? (f--, a--) : 7 === m && (h++, f--, i++, a--), l[l.length - 1].x2 = h, l[l.length - 1].y2 = f, l[l.length - 1].x3 = h, l[l.length - 1].y3 = f; var I = !1; for (var O = 0; O < s.length; O++)s[O].x === h && s[O].y === f && (I = !0, m = s[O].linesgement); if (I) { if (h === u && f === d) { S = !0; break } var P = Math.abs(i), A = Math.abs(a); P > 1 && (P = 1), A > 1 && (A = 1); var L = Math.abs(l[l.length - 1].x2 - l[l.length - 1].x1), E = Math.abs(l[l.length - 1].y2 - l[l.length - 1].y1); if (L > r || E > r) { l[l.length - 1].x3 = l[l.length - 1].x2, l[l.length - 1].y3 = l[l.length - 1].y2; var j = 0; 0 === m ? j = 0 : 1 === m ? j = 1 : 2 === m ? j = 2 : 3 === m ? j = 3 : 4 === m ? j = 4 : 5 === m ? j = 5 : 6 === m ? j = 6 : 7 === m && (j = 7), l[l.length] = [], l[l.length - 1].type = j, l[l.length - 1].x1 = h, l[l.length - 1].y1 = f, l[l.length - 1].x2 = h, l[l.length - 1].y2 = f, l[l.length - 1].x3 = h, l[l.length - 1].y3 = f, i = 0, a = 0 } } } else S = !0 } return l },
            batchtracelayers: function (t, r, e) { for (var n = 0; n < t.length; n++)for (var o = 0; o < t[n].paths.length; o++)t[n].paths[o].segments = ImageTracer.tracepath(t[n].paths[o], r, e); return t },
            batchcolorlayers: function (t, r, e) { for (var n = 0; n < t.length; n++)t[n].color = e[n]; return t },
            getsvgstring: function (t, r) { r = ImageTracer.checkoptions(r); var e = '<svg width="' + t[0].width * r.scale + '" height="' + t[0].height * r.scale + '" viewBox="0 0 ' + t[0].width * r.scale + " " + t[0].height * r.scale + '" version="1.1" xmlns="http://www.w3.org/2000/svg" >'; for (var n = 0; n < t.length; n++) { var o = "rgb(" + t[n].color.r + "," + t[n].color.g + "," + t[n].color.b + ")", i = ""; for (var a = 0; a < t[n].paths.length; a++) { var s = t[n].paths[a].segments, l = "M " + s[0].x1 * r.scale + " " + s[0].y1 * r.scale + " "; for (var c = 0; c < s.length; c++)l += "L " + s[c].x2 * r.scale + " " + s[c].y2 * r.scale + " "; l += "Z ", i += l } e += '<path fill="' + o + '" stroke="' + o + '" stroke-width="' + r.strokewidth + '" opacity="' + t[n].color.a / 255 + '" d="' + i + '" />' } return e += "</svg>" },
            blur: function (t, r, e) { var n = t.data, o = t.width, i = t.height, a = r, s = e, l = new Uint8ClampedArray(n.length); for (var c = 0; c < l.length; c++)l[c] = n[c]; for (var u = 0; u < a; u++) { for (var d = 0; d < i; d++)for (var h = 0; h < o; h++) { var f = 4 * (d * o + h), m = 0, p = 0, g = 0, v = 0, b = 0; for (var y = -1; y <= 1; y++)for (var w = -1; w <= 1; w++) { var k = h + w, x = d + y; if (k >= 0 && k < o && x >= 0 && x < i) { var T = 4 * (x * o + k); m += n[T], p += n[T + 1], g += n[T + 2], v += n[T + 3], b++ } } l[f] = m / b, l[f + 1] = p / b, l[f + 2] = g / b, l[f + 3] = v / b } for (var c = 0; c < l.length; c++)n[c] = l[c] } return t }
        };
    </script>
</head>
<body>
    <div class="glow glow-1"></div>
    <div class="glow glow-2"></div>

    <aside>
        <h1><span>Vector</span>Studio</h1>

        <div class="control-group">
            <button class="btn btn-outline" onclick="document.getElementById('fileInput').click()">üìÇ Open Image</button>
            <input type="file" id="fileInput" accept="image/*" style="display:none">
        </div>

        <h2>Settings</h2>
        <div class="control-group"><label>Colors <span id="val-colors">16</span></label><input type="range" id="opt-colors" min="2" max="64" value="16" step="1"></div>
        <div class="control-group"><label>Noise <span id="val-noise">2</span></label><input type="range" id="opt-noise" min="0" max="100" value="2" step="1"></div>
        <div class="control-group"><label>Smoothness <span id="val-smooth">1</span></label><input type="range" id="opt-smooth" min="0" max="5" value="1" step="0.1"></div>
        <div class="control-group"><label>Stroke <span id="val-stroke">0</span></label><input type="range" id="opt-stroke" min="0" max="5" value="0" step="0.5"></div>
        
        <div class="control-group" style="margin-top:15px">
            <div class="switch-wrap" onclick="document.getElementById('opt-bg').click()">
                <label style="margin:0; cursor:pointer">Transparent BG</label>
                <input type="checkbox" id="opt-bg"><div class="toggle"></div>
            </div>
        </div>

        <button class="btn" id="applyBtn">Refresh</button>
        <h2 style="margin-top: auto">Export</h2>
        <button class="btn" style="background: #30D158" id="downloadBtn">Download SVG</button>
    </aside>

    <main id="mainCanvas">
        <div class="upload-ui" id="uploadOverlay">
            <div class="upload-btn" onclick="document.getElementById('fileInput').click()">
                <div style="font-size:40px; margin-bottom:10px">üì∑</div>
                <div style="font-size:18px; font-weight:600">Drop Image Here</div>
            </div>
        </div>

        <div class="canvas-container" id="compareWrapper">
            <div class="original-layer"><img id="originalImg" class="layer"></div>
            <div class="vector-layer-mask" id="vectorMask">
                <div id="svgContainer"></div>
            </div>
            <div class="handle" id="sliderHandle"></div>
        </div>

        <div class="loading-pill" id="statusBar">
            <div class="spin"></div><span id="statusText">Processing...</span>
        </div>
    </main>

    <script>
        // --- Main Logic ---
        const els = {
            file: document.getElementById('fileInput'),
            upload: document.getElementById('uploadOverlay'),
            main: document.getElementById('mainCanvas'),
            wrapper: document.getElementById('compareWrapper'),
            origImg: document.getElementById('originalImg'),
            svgCont: document.getElementById('svgContainer'),
            mask: document.getElementById('vectorMask'),
            handle: document.getElementById('sliderHandle'),
            status: document.getElementById('statusBar'),
            statusTxt: document.getElementById('statusText'),
            inputs: {
                colors: document.getElementById('opt-colors'),
                noise: document.getElementById('opt-noise'),
                smooth: document.getElementById('opt-smooth'),
                stroke: document.getElementById('opt-stroke'),
                bg: document.getElementById('opt-bg')
            }
        };

        // Sync Range Values
        Object.keys(els.inputs).forEach(k => {
            if(k!=='bg') els.inputs[k].addEventListener('input', e => document.getElementById(`val-${k}`).innerText = e.target.value);
        });

        let imgData = null;

        // File Handling
        els.file.addEventListener('change', e => { if(e.target.files[0]) loadFile(e.target.files[0]); });
        
        els.main.addEventListener('dragover', e => { e.preventDefault(); els.main.classList.add('drag-active'); });
        els.main.addEventListener('dragleave', e => { e.preventDefault(); els.main.classList.remove('drag-active'); });
        els.main.addEventListener('drop', e => {
            e.preventDefault(); els.main.classList.remove('drag-active');
            if(e.dataTransfer.files[0]) loadFile(e.dataTransfer.files[0]);
        });

        function loadFile(file) {
            if(!file.type.match('image.*')) return alert("Not an image file");
            setLoad(true, "Reading...");
            const reader = new FileReader();
            reader.onload = e => {
                const img = new Image();
                img.onload = () => {
                    els.origImg.src = img.src;
                    els.upload.style.display = 'none';
                    els.wrapper.style.display = 'block';
                    
                    const cvs = document.createElement('canvas');
                    cvs.width = img.width; cvs.height = img.height;
                    const ctx = cvs.getContext('2d');
                    ctx.drawImage(img,0,0);
                    imgData = ctx.getImageData(0,0,img.width,img.height);
                    
                    setTimeout(() => runTrace(), 100);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // Tracing
        document.getElementById('applyBtn').addEventListener('click', () => runTrace(true));
        document.getElementById('downloadBtn').addEventListener('click', dlSVG);

        function runTrace(manual) {
            if(!imgData) return;
            setLoad(true, manual?"Updating...":"Vectorizing...");
            
            setTimeout(() => {
                try {
                    const opts = {
                        ltr:true, 
                        numberofcolors: parseInt(els.inputs.colors.value),
                        turdsize: parseFloat(els.inputs.noise.value),
                        ltres: parseFloat(els.inputs.smooth.value),
                        qtres: parseFloat(els.inputs.smooth.value),
                        strokewidth: parseFloat(els.inputs.stroke.value),
                        scale:1, viewbox:true, linefilter:true
                    };
                    
                    // Core Call
                    let svg = ImageTracer.imagedataToSVG(imgData, opts);
                    if(els.inputs.bg.checked) svg = svg.replace(/<path[^>]*fill="rgb\(255,255,255\)"[^>]*\/>/g, "");
                    
                    els.svgCont.innerHTML = svg;
                    // Fix Layout
                    const svgEl = els.svgCont.querySelector('svg');
                    if(svgEl) {
                        svgEl.removeAttribute('width'); svgEl.removeAttribute('height');
                        svgEl.style.width = els.origImg.clientWidth+'px';
                        svgEl.style.height = els.origImg.clientHeight+'px';
                    }
                    window.blobSvg = svg;
                    setLoad(false);
                } catch(e) {
                    console.error(e); alert("Error: "+e.message); setLoad(false);
                }
            }, 50);
        }

        function dlSVG() {
            if(!window.blobSvg) return;
            const url = URL.createObjectURL(new Blob([window.blobSvg], {type:'image/svg+xml'}));
            const a = document.createElement('a');
            a.href = url; a.download = 'vector_pro.svg'; a.click();
        }

        function setLoad(on, txt) {
            els.statusTxt.innerText = txt;
            on ? els.status.classList.add('show') : els.status.classList.remove('show');
        }

        // Slider Logic
        let drag = false;
        els.handle.addEventListener('mousedown', () => drag=true);
        window.addEventListener('mouseup', () => drag=false);
        window.addEventListener('mousemove', e => {
            if(!drag) return;
            const rect = els.wrapper.getBoundingClientRect();
            let x = e.clientX - rect.left;
            x = Math.max(0, Math.min(x, rect.width));
            const pct = (x/rect.width)*100;
            els.mask.style.width = pct+'%';
            els.handle.style.left = pct+'%';
        });
        
        // Resize fix
        window.addEventListener('resize', () => {
            const svgEl = els.svgCont.querySelector('svg');
            if(svgEl) {
                svgEl.style.width = els.origImg.clientWidth+'px';
                svgEl.style.height = els.origImg.clientHeight+'px';
            }
        });
    </script>
</body>
</html>